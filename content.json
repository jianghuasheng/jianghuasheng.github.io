[{"title":"自己动手搭建短网址服务器","date":"2017-10-12T12:54:09.000Z","path":"2017/10/12/自己动手搭建短网址服务器/","text":"自己动手搭建短网址服务器 前段时间小博主在公司工作的时候发现有个项目经常会用到短网址服务，收集了下资料，写了下开发流程就开始弄了，然后就在公司的服务器上搭建了一个简单的短网址服务，用到现在基本也没出什么问题，具体的开发和搭建流程如下： 前提条件： Linux服务器（Centos系统） PHP运行环境（Nginx环境） Mysql数据库 开发流程：一、简单的功能分析通过调研发现，该功能需求主要由以下几个组成： 把长链接转换成短链接的功能模块 把短链接还原成长链接的功能模块 统计记录短网址转换长网址的日志 线上部署 二、部分核心代码 文件结构主要有三个： a、build.php (生成短链接功能并且存储到数据库里)；b、db.php (数据库连接配置)c、index.php (短链接还原长链接的接口); 1. 长链接生成短链接的功能 这里的核心代码主要是通过接受用户输入的长链接的值，然后再通过简单的判断是否存在，如果存在该长链接记录则直接返回已经生成的那个短链接。如果不存在转换记录，通过简单的算法生成不重复的6位字符串来标识该长链接,再把标志码传到数据库记录转换记录。 长链接生成短链接的功能源码地址 2. 短链接还原长链接的功能 该模块主要是通过对接收用户传过来的短网址后面的6位标志码来去查找数据库里面存在的长链接记录，同时记录用户的访问日志等。 短链接还原长链接的功能源码地址 三、线上部署 想直接配置类似这种‘http://s.jianghuasheng.cn/Gjhg4o’=&gt;域名+6位标识码就可以访问的，需要在nginx虚拟主机的配置文件那里配置。主要是在配置文件里加上重定向的配置，如下（注意：这里的是Nginx的环境配置，Apache的请前往百度）： 12345location / &#123; if (!-e $request_filename)&#123; rewrite ^(.*)$ /index.php?url=$1 last; break; &#125; &#125; 这里的意思主要是指默认把链接：‘http://s.jianghuasheng.cn/Gjhg4o’转换为‘http://s.jianghuasheng.cn/index.php?url=Gjhg4o’。当然，配置成类似‘http://jianghuasheng.cn/s/Gjhg4o’的方法也是大概一直的，这里不一一介绍了。 总结 实现这个功能并不是很难，但是有几点还是要注意下的：保证每次生成的标志码都是不一样的！这里通过网上找到的一个算法，通过对用户传过来的连接进行处理，得到不同的标志码。长链接不同，标志码生成就不一样了。同时，为了该功能模块的使用简便性，直接架构成接口的模式，直接直接调用接口就可以实现功能。","tags":[]},{"title":"iframe无阻塞异步加载实例","date":"2017-04-26T14:50:56.000Z","path":"2017/04/26/iframe无阻塞异步加载实例/","text":"iframe无阻塞异步加载实例 小博主今天在优化公司项目的一个门户网站的加载速度的时候遇到一个很大的问题，没错，就是关于在页面引入iframe。而且是在主页面中调用微博秀。最开始使用的直接是在页面引入iframe元素，这样不仅阻碍了页面的onload事件的加载，而且当iframe在加载的过程中，浏览器会标识正在加载，处于忙碌状态。对用户的体验超级不友好，而且是首页，所以就纠结了下关于iframe无阻塞异步加载技术。关于iframe的加载技术，可以看看这篇我转载的别人的文章：iframe异步加载技术及性能 下面主要介绍的是上面文章中的第四种方法，iframe无阻塞异步加载，用来加载微博秀的应用实例。线上的实例地址为：茂名市公安局 废话少说，我先直接上代码^^ //iframe异步无阻塞加载 function iframeWeiboData(data) { var iframe = document.getElementById('iframeWeiboId'); doc = document.getElementById('iframeWeiboId').contentWindow.document; doc.open().write(data); } (function() { var d = document.getElementById(\"weibo_ad_weibo\"); var iframe = d.appendChild(document.createElement('iframe')), doc = iframe.contentWindow.document; iframe.scrolling=\"no\"; iframe.id=\"iframeWeiboId\"; iframe.style.cssText =\"width:100%;height:407px;border:none;\"; doc.open().write('&lt;script&gt;function showWeiBo(data) {window.parent.iframeWeiboData(data);};&lt;\\/script&gt;&lt;body id=\"weiboBox333\" onload=\"'+'var d = document;d.getElementsByTagName(\\'head\\')[0].'+'appendChild(document.createElement(\\'script\\')).src'+'=\\'\\http://gdmm110.cn:88\\/Home\\/CommonApi\\/getWeiboData\\'\"&gt;&lt;img id=\"weiboimg333\" src=\"http://gdmm110.cn:88\\/Public\\/Home\\/images\\/weibopic.jpg\" style=\"display:block;margin: 0px auto;margin-top: 45px;\"&gt; &lt;p id=\"loadingtext333\" style=\"font-size: 18px;line-height: 45px;width: 100%;text-align: center;color:#B67655;\"&gt;平安茂名微博加载中...&lt;/p&gt;'); doc.close(); })(document); 我先解析下这段代码：首先先动态创建一个iframe，然后设置他的属性（不设置src）。再往他的contentWindow里面添加onload事件，在里面动态创建head异步加载iframe的地址，这里就相当于jsonp原理一样了。当时，这样个iframe既不在onload之前加载，而且还不会阻塞主页面的加载。head里面的那个script的地址是经过处理的，我是直接通过后端处理，把微博秀的页面压缩，再以一个方法返回来给页面，标准的jsonp操作。然后就直接调用方法把iframe里面的html全部换掉。整个过程大概就这样子。其实我觉得这里运用后端的知识来配合解决有点不妥，所以，大家有什么好的建议可以共享下。","tags":[]},{"title":"阿里2017前端工程师实习生笔试题","date":"2017-04-24T14:18:46.000Z","path":"2017/04/24/阿里2017前端工程师实习生笔试题/","text":"阿里2017前端工程师实习生笔试题总结 小博主于今天（2017-04-24）晚上19点的时候笔试了阿里2017前端工程师实习生笔试的编程题目。第二次写关于阿里笔试的总结了，上一次是内推的时候（传送门：2018年春季阿里前端工程师实习岗在线测评编程题总结），那时候只有一道编程题，但是直接给kill掉了。不过也好，能有机会再次考验下自己。 好吧，这次也基本是一点准备都没有。基本都是用工作或者平时的积累来答的。而且太急了，18点20才从公司回学校。直接打了个饭就回宿舍都已经19点多了，打开电脑直接上了。答题的时候一直看着我的饭…^^— 大家关注的应该还是考了什么题吧^^ 这次题型也很大众化，分为以下三种： 1~10：选择题 选择题主要考察了些比较新颖的前端技术，例如websocket、ES6和一些通讯协议原理等等的题。（我居然忘记截图了^^）都是不定项的选择题哟。 11、12：编程题 编程题主要是根据要求来写部分实现的js。这里可以用本地的IDE哟。 第一题主要是过滤和替换特定的字符串的功能实现。功能上算是实现了吧，但是很多代码是重复的（解答的代码如下），还有很多地方需要优化。这里主要是写第二个的实现哈，因为那时没时间，直接没做。^^ 123456789101112131415161718192021222324252627282930313233343536var transformMsg = function(msg, keyword)&#123; //初始化 var newMsg = ''; // 没有定义关键字 if(keyword == '')&#123; //判断msg中是否含有@ if(msg.indexOf(\"@\") &gt; -1)&#123; //截取msg中除了@的其他字符 var nickname = msg.substr(msg.length-1); // 替换特定字符串 newMsg = msg.replace('@', \"&lt;a href='/profile/\"+nickname+\"' target='_blank'&gt;\"); newMsg = newMsg+\"&lt;/a&gt;\"; return newMsg; &#125;else&#123; return msg; &#125; &#125;else&#123; //判断msg中是否含有@ if(msg.indexOf(\"@\") &gt; -1)&#123; //截取msg中除了@的其他字符 var nickname = msg.substr(msg.length-1); // 替换特定字符串 newMsg = msg.replace('@', \"&lt;a href='/profile/\"+nickname+\"' target='_blank'&gt;\"); newMsg = newMsg+\"&lt;/a&gt;\"; //判断是否含有关键字 if(newMsg.indexOf(keyword) &gt; -1)&#123; newMsg = newMsg.replace(keyword, \"&lt;em class='highlight'&gt;\"+keyword+\"&lt;/em&gt;\"); &#125;else&#123; return newMsg; &#125; &#125;else&#123; return msg; &#125; &#125; &#125; 第二题的内容喔复制下来了！好吧，是因为我当时没做，想自己再做做。下面是题目和我的实现方法： 12345678//题目：写一个十进制（整数）字符串至二进制字符串的转码函数，能够保证以下Case的正确处理。请完善your code here部分function decimalToBinary (decimalStr) &#123; // your code here return binaryStr;&#125; decimalToBinary('50')// return '110010'decimalToBinary('5050120') // return '10011010000111100001000'decimalToBinary('102030102123412343') // return '101101010011110111101011001011001011101100111101101110111' 其实这个不难，就是当时傻傻地想看看最后一题，所以就忽略了^^。然后最后一题还不会…通过分析，主要是有两个判断，和利用递归循环来转码。第一先是判断是否那个十进制已经小于或等于0，是的话直接输出binaryStr，不是的话就进行第一个判断，判断递归的数字除2是否有余数，有的直接在binaryStr字符串前面拼接上1，同时递归的decimalStr去掉小数部分。能整除2的话直接在binaryStr的前面拼接0，decimalStr除于2继续循环递归。下面演示代码： 1234567891011121314151617181920function decimalToBinary (decimalStr) &#123; // 定义空字符串 var binaryStr = ''; do&#123; //判断是否整除(整除，则二进制位为0；否则为1，且去掉小数部分) if(decimalStr%2 == '1')&#123; decimalStr=parseInt(decimalStr/2); //直接拼接字符串 binaryStr = \"1\"+binaryStr; &#125;else&#123; decimalStr = decimalStr/2; binaryStr = \"0\"+binaryStr; &#125; &#125;while(decimalStr &gt; 0); return binaryStr;&#125; decimalToBinary('50')// return '110010'decimalToBinary('5050120') // return '10011010000111100001000'decimalToBinary('102030102123412343') // return '101101010011110111101011001011001011101100111101101110000' 本来想用递归方法来实现的，但是代码只能写在decimalToBinary方法里面，又不好在外面定义binaryStr，所以就直接用了do while循环，功能上能实现。 这里网上还有一种比较简单的办法，就是把一个 Number 对象转换为一个字符串，并返回结果。就是toString()的用法：toString（）语法：NumberObject.toString(radix);其中，radix为可选。规定表示数字的基数，使 2 ~ 36 之间的整数。若省略该参数，则使用基数 10。但是要注意，如果该参数是 10 以外的其他值，则 ECMAScript 标准允许实现返回任意值。parseInt(num,8); //八进制转十进制parseInt(num,16); //十六进制转十进制parseInt(num).toString(8) //十进制转八进制parseInt(num).toString(16) //十进制转十六进制parseInt(num,2).toString(8) //二进制转八进制parseInt(num,2).toString(16) //二进制转十六进制parseInt(num,8).toString(2) //八进制转二进制parseInt(num,8).toString(16) //八进制转十六进制parseInt(num,16).toString(2) //十六进制转二进制parseInt(num,16).toString(8) //十六进制转八进制 1234567function dec2bin(num)&#123; if(isNaN(num))return; console.log(parseInt(num,10).toString(2));&#125;dec2bin('50')// return '110010'dec2bin('5050120') // return '10011010000111100001000'dec2bin('102030102123412343') // return '101101010011110111101011001011001011101100111101101110000' 注：这里还有一个考点就是js处理数字时的溢出处理。js处理数字时不能超过16位，如果超出16都是用0替代。所以最后一个案例18位的情况出错了。 这种情况网上的解决方案基本没有，我想主要是想通过对传入的数字的位数进行位数判断，超过16则进行位数分割，例如传入的是17位数的，传入的数字先转化为二进制，再截取16位之后的值的，再转化为二级制，两个再相与。具体的代码再仔细考虑下，择日提交上来哈。 13：简答题 最后一道题最好是简单题，是关于webscoket的做一个聊天室问题。关键是对整一个协议、功能实现等的考察。小博主基本没用过他来开发项目(基本都是用ajax轮询来解决平时的通讯，而且webscoket用php来做后台很难实现，所以一直能去深入了解^^.等有空了解了nodejs再好好品味下这个功能)，所以基本没答。^^ 总结： 这次感觉没有第一次那么紧张了，但是却没有上次那么多时间来思考，因为最近确实有点忙。","tags":[]},{"title":"数组迭代器方法总结","date":"2017-04-23T12:37:43.000Z","path":"2017/04/23/数组迭代器方法总结/","text":"数组迭代器方法总结 数组迭代器方法，对数组中的每个元素应用一个函数，可以返回一个值、一组值或者一个新数组。主要分为以下两类： 一、不生成新数组的迭代器方法 该类的特点是不产生任何新的数组，要么对数组的每个元素执行某种操作，要么返回一个值。主要有forEach()和every()方法。 forEach()方法 forEach()接收一个函数作为参数，对数组的每个元素使用该函数。 123456789function square(num) &#123; console.log(num,num*num);&#125;var nums = [1,2,3];nums.forEach(square);//结果//&gt;1 1//&gt;2 4//&gt;3 9 every()方法 every()接收一个返回值为布尔类型的函数，对数组的每个元素使用该函数。如果对于所有的元素，该函数均返回true，则该方法返回true。 12345678910111213function isEven(num) &#123; return num%2 == 0;&#125;var nums = [2,4,6]; var ret = nums.every(isEven); console.log(ret); //结果 //&gt;true //------------------------ var nums = [2,4,6]; var ret = nums.every(isEven); console.log(ret); //&gt;false 扩展： some()方法的用法和every()的方法一样，唯一区别就是：只要有一个元素使得该函数返回true，该方法就返回true。 reduce()方法接收一个函数，返回一个值。该方法会从一个累加值开始，不断对累加值和数组中的后续元素调用该函数，最后返回得到的累加值。（也可以将数组中元素连接成字符串） 12345678function add(tol,cur) &#123; return tol+cur;&#125;var nums = [1,2,3]; var ret = nums.reduce(add); console.log(ret); //结果 //&gt;6 reduceRight()方法用法和reduce()一样，但它是从右到左执行的。 二、生成新数组的迭代器方法 有两个迭代器方法可以产生新数组：map()和filter(); map()方法 map()方法和forEach()方法有点像，都是对数组的每个元素使用某个函数。但是map()返回一个新的数组，该数组的元素是对原有元素应用某个函数得到的结果。 filter()方法 filter()和every()方法类似，传入一个返回值为bool类型的函数。和every()方法不同的是，当数组中的所有元素应用该函数，结构均为true时，该方法并不是和every一样返回true，而是返回一个新数组，该数组包含该函数后结果为true的元素。 当然，还可以使用filter()方法来过滤字符串数组。 1234567891011function has(str) &#123; if(str.indexOf(\"o\") &gt; -1)&#123; return true; &#125; return false;&#125;var nums = [\"ocean\",\"ocean3\",\"huazai\"]; var ret = nums.filter(has); console.log(ret); //结果 //&gt;[\"ocean\", \"ocean3\"]","tags":[]},{"title":"SSE+ajax实现无刷新服务器实时推送功能","date":"2017-03-28T12:45:40.000Z","path":"2017/03/28/SSE-ajax实现无刷新服务器实时推送功能/","text":"SSE+ajax实现无刷新服务器实时推送功能 这个小功能主要是大家平时用的聊天软件的底层技术，通过页面无刷新和服务器长连接的技术无刷新地去推送最新的消息。对于实时推的技术，主要有HTML5中的EventSource和Websocket事件。之前做过一个订单提醒功能，最要是客户端运用ajax进行轮询，但是这个对服务器造成的压力很大，浪费内存资源等等。所以，这里探讨下EventSource的简单使用。这里主要用到的技术有php的PDO、SSE（HTML5 服务器发送事件server-sent event，EventSource）、ajax和js框架zepto。下面主要介绍下实现的流程： 这里是案例测试地址：http://exam.jianghuasheng.cn/sse/index.html这里是项目github地址：https://github.com/jianghuasheng/SSE 实现该功能主要分为二个主要部分：一、无刷新取出聊天记录（SSE、EventSource） 取出聊天记录而且页面无刷新，以前第一想到的就是用ajax去轮询接口拉取最新的数据，但是在HTML5中出了服务器发送事件（server-sent event），就是允许网页自动获得来自服务器的更新。具体的介绍可以看下官方的文档http://www.w3school.com.cn/html5/html_5_serversentevents.asp。 这里主要看下他的原理和怎样去运用：W3C:HTML5 服务器发送事件（server-sent event）允许网页获得来自服务器的更新。下面主要看下他的应用： 关键代码区 // 检测是否支持EventSource事件 if(typeof(EventSource)!==\"undefined\"){ // SSE 服务器推事件 var es = new EventSource(\"index.php?a=getMsg\"); // console.log(es); // 对返回的数据进行处理 es.onmessage=function(e){ document.getElementById('ul').innerHTML=e.data; // 布局定位 var h = document.getElementById('ul').offsetHeight; var h2 = document.body.offsetHeight; // 自动滚动到底部 document.getElementById('con').scrollTop=h-h2; }; }else{ alert(\"亲，您的浏览器暂不支持该功能哟，请您换个浏览器试试哈^^\"); } 使用EventSource事件很简单，直接new一个EventSource对象就可以了，但是IE浏览器不支持该事件，所以要判断下不支持的的情况下的提醒或者处理，这里直接是提醒不支持^^，如果是IE浏览器可以直接用户原来的那个ajax轮询的模式。 下面是EventSource事件的一些属性截图: 再来看看用ajax提交的时候的情况： 细心的你可能会发现，其实ajax和EventSource事件差不多，就是EventSource事件会比较容易使用。当然，他们还是有区别的。EventSource事件，就是浏览器通过HTTP向服务器发送请求，服务器端拿出数据库中的数据，立即返回给客户端，客户端等待三秒后再次发出下一个请求。其实我个人理解功能上就是可以想成每隔三秒执行下ajax，但是却没有ajax那么复杂的流程。 三、后端处理代码(PDO) 这里后台主要运用了PDO对象来操作数据库。不懂得什么是PDO的可以看下这里http://blog.csdn.net/j_h_s/article/details/67644330和官方文档http://www.php.net/manual/zh/pdo.connections.php。我直接上整个处理类的的代码吧^^ // +---------------------------------------------------------------------- // | Copyright (c) 2017 http://www.jianghuasheng.cn All rights reserved. // +---------------------------------------------------------------------- // | Author: 江华生 &lt;jianghuasheng333gmail.com&gt; 2017-03-27 // +---------------------------------------------------------------------- // | Desc: 本类为简单的SSE服务端的处理代码。参考了极客学院的课程代码。 // +---------------------------------------------------------------------- class SSEController{ //声明静态变量保存数据库的连接信息 private static $pdo = NULL; // 构造函数，这里保存连接数据库信息的变量值 public function __construct(){ // 判断是不是第一次链接数据库 if (is_null(self::$pdo)) { try { $pdo = new PDO('mysql:host=localhost;dbname=sse', 'root', '',array(PDO::ATTR_PERSISTENT =&gt; true)); // 设置编码 $pdo-&gt;query('SET NAMES UTF8'); // 保存到定义好的静态变量中 self::$pdo = $pdo; // var_dump($pdo); } catch (PDOException $e) { // print \"Error: \" . $e-&gt;getMessage() . \"&lt;br/&gt;\"; die(\"Content Error!\"); } } } // 主页面 public function index(){ // echo \"index页面\"; include \"./index.html\"; } // 获取数据库聊天记录 public function getMsg(){ // 表明是事件流 header('Content-Type:text/event-stream'); // 不要缓存 header('Cache-Control:no-cache'); // sql语句 $sql = \"SELECT * FROM msg ORDER BY id ASC\"; // 查询结果对象 $result = self::$pdo-&gt;query($sql); // 结果结构化 $rows = $result-&gt;fetchALL(PDO::FETCH_ASSOC); // foreach ($rows as $k =&gt; $v) { $name = $v['name']; $msg = $v['msg']; $time = $v['time']; if ($k == 0) { echo \"data:&lt;li&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;{$name} : &lt;/b&gt;{$msg}&lt;i&gt; ({$time})&lt;/i&gt;&lt;/li&gt;\"; }else{ echo \"&lt;li&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;{$name} : &lt;/b&gt;{$msg}&lt;i&gt; ({$time})&lt;/i&gt;&lt;/li&gt;\"; } } echo \"\\n\\n\"; //立即将数据返回给客户端 ，@：忽略错误 @ob_flush();@flush(); } // 新增聊天信息 public function addMsg() { if (isset($_POST['name']) &amp;&amp; isset($_POST['message'])) { $name = $_POST['name']; $message = $_POST['message']; //判断是否为空 if (empty($name) || empty($message)) { // 不能为空 $ret = array('code' =&gt; 401,'msg'=&gt;\"亲，昵称或者聊天内容不可以为空哟！\"); echo json_encode($ret); exit; }else{ $nowTime = date('Y-m-d H:i:s',time()); // 执行插入数据库操作 $Sql = \"INSERT INTO msg (name,time,msg) values ('\".$name.\"','\".$nowTime.\"','\".$message.\"');\"; $reslut = self::$pdo-&gt;exec($Sql);//返回影响了多少行数据 if ($reslut) { //非法传参 $ret = array('code' =&gt; 200,'msg'=&gt;\"插入成功\"); echo json_encode($ret); exit; }else{ //非法传参 $ret = array('code' =&gt; 401,'msg'=&gt;\"401：亲，新增失败！亲您重试下...\"); echo json_encode($ret); exit; } } }else{ //非法传参 $ret = array('code' =&gt; 400,'msg'=&gt;\"非法传参\"); echo json_encode($ret); exit; } } } $controller = new SSEController; // 在URL那里传参?a=来控制要执行类的方法，默认为index方法 // 用法eg：?a=getMsg 执行类的getMsg方法 $action = isset($_GET['a']) ? $_GET['a'] : 'index'; $controller-&gt;$action(); 总结： 这个小功能比较简单，主要是对HTML 5 服务器发送事件EventSource的使用和原理的简单介绍以及php的PDO的简单使用。 后台的php的代码架构参考了极客学院的课程的封装思想。觉得挺不错的，所以直接贴上去大家交流下。 当然，这个功能还有很多小细节要去思考下的。例如以下几点: 怎样去兼容IE浏览器？其实就是用ajax轮询应该也可以吧。 聊天输入框不能插入图片和表情包，嗯，这个得好好研究下^^。 如何去艾特或者回复特定的人的设计等等。 嗯，就写这么多了，下次和大家一起学习下WebSockets的原理和使用^^。 这里是案例测试地址：http://exam.jianghuasheng.cn/sse/index.html这里是项目github地址：https://github.com/jianghuasheng/SSE","tags":[]},{"title":"PHP模拟登录教务系统并获取数据","date":"2017-03-24T14:57:16.000Z","path":"2017/03/24/PHP模拟登录教务系统并获取数据/","text":"PHP模拟登录学校教务系统并获取数据 这个小功能主要的代码是当时创业校联圈（大概在2016-09月）的时候写的，当时这个功能模块没有真正上线运营，所以今天开源给大家，和大家聊聊其中的技术^^。这里主要是运用了PHP中的一个CURL库。CURL是一个功能强大的PHP库，可以简单和有效地抓取网页并采集内容，设置cookie完成模拟登录网页。 这里是测试传送门（仅限广东石油化工学院同学哟） 好了，以下主要介绍下实现的过程，有错误或者有更好的办法欢迎留言交流^^ 这里主要分为两个比较关键点的步骤：一、爬出登陆教务系统时要提交的数据 登陆教务系统的时候要输入学号和密码，但是这两肯定是不够的，如下图。所以这里用了Fiddler来抓提交的数据（不知道Fiddler的使用的同学可以百度下哈），然后就设置curl时要提交的数据来模拟登陆。（不知道curl的具体使用的同学可以看看这里http://blog.csdn.net/j_h_s/article/details/65698343） 分析登陆时要提交的数据 登陆时fiddler抓包的数据 curl设置的数据 登陆成功后台主页 二、模拟登陆后抓取的数据处理 登陆成功后关键是怎样去爬我们需要排课或者成绩等信息呢？通过分析，这个教务系统的后台主要是通过生成json数据存储课程等信息。所以我用curl_exec函数返回的页面的数据通过特定字符串来截取我们需要的信息。大概步骤如下图： 通过分析排课页面获得的数据 接收接受返回的数据 特定字符串截取关键数据 到这就基本实现目的了，接下来就是简单的页面显示爬得的数据了，这里就不做介绍了，附上测试的结果图和地址^^这里是测试传送门（仅限广东石油化工学院同学哟） 后语： 当然，真正上线运营可能就起来并没有这么简单，例如我们这里是直接每次登录来获得用户的学号和密码，为了更便捷，可以用数据库来保存用户的信息或者绑定到其他账号，就好像微信那里一样。还有，就是当用户输入错误的学号或者密码怎么判断等等，这里只做简单的介绍，欢迎留言讨论^^! 最后附上测试地址和github地址 测试地址：http://exam.jianghuasheng.cn/course/index.html 源码github","tags":[]},{"title":"2018年春季阿里前端工程师实习岗在线测评编程题","date":"2017-03-19T00:56:19.000Z","path":"2017/03/19/2018年春季阿里前端工程师实习岗在线测评编程题/","text":"2018年春季阿里前端工程师实习岗在线测评编程题总结 小博主于昨天（2017-03-18）早上大概9点的时候在线测评了阿里2018年春季校园招聘前端工程师实习岗位的编程题目。算是小博主的第一次比较正式的在线编程了（把第一次给了她，哈），而且在这30min的时间内，有很多的感谢也想和大家分享下，所以今天写下这个小博客，多多交流。 首先，大家很关注的应该就是考了什么题吧^^没错，就是考了js的简单运用。下面是简单的题目要求介绍，具体的记不清楚了（居然忘了截屏！！）。 在下面的样式中，当鼠标滚动的时候，box1以鼠标滚动2倍的速度运动，box2以鼠标滚动3倍的速度运动。大致效果如下图。 原始代码是这样的 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body style=\"height: 5000px\" id=\"wrapper\"&gt; &lt;div style=\" width: 300px; height: 100px; background:#000;\" id=\"box1\"&gt;&lt;/div&gt; &lt;div style=\" width: 300px; height: 100px; background:red;\" id=\"box2\"&gt;&lt;/div&gt; &lt;script&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后直接在她测试的页面阿里写js，当然，可使用本地IDE编程工具。所以当时我用了自己最熟悉的Sumline和谷歌来编程和测试。 接下来就是在这30min内的事咯&nbsp;&nbsp;&nbsp;&nbsp;前5,6分钟把关键要用到的技术简单地设计了下和在网上搜索下看没有类似的功能，发现资料实现太少了。但是还是找到了个比较正式的监听鼠标滚动的方式。就是注册一个事件来监听，而且兼容IE和W3标准，因为和自己想的方式基本一样，所以二话不说就直接用了。（到这大概花了10min） &nbsp;&nbsp;&nbsp;&nbsp;接下来就是设计和写监听执行的事件了。刚开始什么也没想，先用原生js获取了box1和box2的DOM对象，再获取了浏览器滚动的高度，再用console.log（e）来仔细看看监听事件都传了什么参数过来，发现除了滚动的距离，其他的参数对象基本没什么用。好吧，距离留距离吧，先让他动起来再来自己调调（这可能是受之前项目的影响，用效果来修改代码），然后就陷入了让他动起来的坑。（到这大概花了20min） &nbsp;&nbsp;&nbsp;&nbsp;动起来，当时第一感就是用css3的animation，但是那些兼容性和规则那些要写很多呀！然后看了下题目，没有要求说不能用库，所以直接用了百度的Jquery CDN。就这样，成功用了Jquery里面的animation方法（到这大概用了25min了） &nbsp;&nbsp;&nbsp;&nbsp;动起来之后呢？鼠标滚动的速度怎么获得？这才是关键。当时大致地想了下，肯定是要在animation那里传入移动的位置和时间的参数，而且得让他悬浮起来。所以直接穿了个动态的top参数进去，速度实在没办法解决！所以直接打算至直接按滚动距离比来模拟速度的快慢，但是由于时间快到了，所以直接弄了个变量进去。就这样滚动鼠标那两box1 and box2就跟着滚动，当时写的效果大致是这样了。（到这大概用了28min了） &nbsp;&nbsp;&nbsp;&nbsp;看了下时间，还剩一两分钟！不能再纠结代码了。所以整理了下代码的格式，在注释那里添上了自己的思路和步骤（PS：经管有很多功能没有实现，但是把思路写下来，应该印象会好点吧^^）。就这样，把代码复制到答题区，看了下时间，还剩几秒，赶紧点保存和交卷。就这样，感觉这30min过得最快了。。。 不放弃的我^^ 虽然这30min做得啧啧，但是还是很想去实现下这个效果来证明下自己。所以，在下午好好设计了他的实现的过程。其中也发现很多难点也来和大家分享下。 贴上关键的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 window.onload=function()&#123; // 初始化 var Y = document.body.scrollTop; // 动态加入style var newstyle = document.createElement(\"style\"); // console.log(newstyle); newstyle.setAttribute(\"id\", \"addStyle\"); // document.body.appendChild(newstyle); // console.log(document.getElementsByTagName('head')); document.getElementsByTagName('head')[0].appendChild(newstyle); document.getElementById('box1').style.position=\"fixed\"; document.getElementById('box2').style.position=\"fixed\"; document.getElementById('box2').style.top=\"50px\"; var preY = 0; // console.log(Y); // 定义速度初始值 var speed = 100; var scrollFunc=function(e)&#123; 'use strict'; e=e || window.event; // console.log(e); // 清空动画 document.getElementById('box1').style.animation=\"\"; document.getElementById('box2').style.animation=\"\"; // 定义本次滚动的距离，判断是上下滚动 var distance = e.deltaY; // 用滚动距离来比拟速度 var speed2 = distance/speed; // 或者当前滚动的高度 var curY = document.body.scrollTop; var newStyle2 = document.getElementById('addStyle'); // 向上滚动 if (distance &gt; 0) &#123; // console.log(\"向下滚动\"); // 传入动态滚动距离 newStyle2.innerHTML = '@-webkit-keyframes toDown&#123;0% &#123;top:0px;&#125;50% &#123;top:'+distance+'px;&#125;100% &#123;top:0px;&#125;&#125;\\n'+ '@keyframes toDown &#123;0% &#123;top:0px;&#125;50% &#123;top:'+distance+'px;&#125;100% &#123;top:0px;&#125;&#125;\\n'+'@-webkit-keyframes toDown2&#123;0% &#123;top:50px;&#125;50% &#123;top:'+2*distance+'px;&#125;100% &#123;top:50px;&#125;&#125;\\n'+ '@keyframes toDown2 &#123;0% &#123;top:50px;&#125;50% &#123;top:'+2*distance+'px;&#125;100% &#123;top:50px;&#125;&#125;\\n'; document.getElementById('box1').style.animation=\"toDown \"+speed2/2+\"s\"; document.getElementById('box2').style.animation=\"toDown2 \"+speed2/3+\"s\"; // 向下滚动 &#125;else&#123; // console.log(\"向上滚动\"); // 传入动态滚动距离 newStyle2.innerHTML = '@-webkit-keyframes toDown&#123;0% &#123;top:0px;&#125;50% &#123;top:'+(-distance)+'px;&#125;100% &#123;top:0px;&#125;&#125;\\n'+ '@keyframes toDown &#123;0% &#123;top:0px;&#125;50% &#123;top:'+(-distance)+'px;&#125;100% &#123;top:0px;&#125;&#125;\\n'+'@-webkit-keyframes toDown2&#123;0% &#123;top:50px;&#125;50% &#123;top:'+2*(-distance)+'px;&#125;100% &#123;top:50px;&#125;&#125;\\n'+ '@keyframes toDown2 &#123;0% &#123;top:50px;&#125;50% &#123;top:'+2*(-distance)+'px;&#125;100% &#123;top:50px;&#125;&#125;\\n'; document.getElementById('box1').style.animation=\"toDown \"+(-speed2/2)+\"s\"; ; document.getElementById('box2').style.animation=\"toDown2 \"+(-speed2/3)+\"s\"; ; &#125; &#125; // 注册监听鼠标滚动事件 if(document.addEventListener)&#123; document.addEventListener('DOMMouseScroll',scrollFunc,false); &#125;//W3C //IE/Opera/Chrome window.onmousewheel=document.onmousewheel=scrollFunc;&#125; 效果大致就是下面这样 这里还有很多需要完善，例如： 监听鼠标滚动事件会有问题，就是滚动一次会两次调用方法。 每次滚动的距离基本都是固定的？那怎样去比拟速度的快慢？一开始想到的是用滚动开始、滚动过程中和滚动结束这三个机制，用滚动的总距离来比拟速度的。但时搜了下资料好像没有发现。难道只有touch才有ontouchstart,ontouch,ontouchend三事件机制？这里直接用的是每次滚动的距离来比拟速度的快慢。再动态传入滚动的高度作为两div移动的距离。但速度还是很不明显。希望大家有更好的办法分享下^^ 反思和总结 受中国式教育太深，每每到考试都会有些紧张。发挥确实不好。 很关键的是自己没有在知道要实现的效果后好好设计下整个架构，至少也应该弄个流程图来，把核心的代码简单写下（平时都有这习惯，这30min不知道想哪里去了） 当然，最关键的还是自己的阅历太少了，前端技术的基础知识也很差，很多方法内置的参数都不了解 做完这题真的有点思考人生了！以前做项目或者解决问题的思维可能不太适合。所以，虽然做的很糟，但是还是很有意义。至少知道自己哪里需要进步!^^ 好吧，就写这么多先。等遇到类似的案例再仔细想想这个。^^","tags":[{"name":"面试心得","slug":"面试心得","permalink":"https://jianghuasheng.github.io/tags/面试心得/"}]},{"title":"Array类型","date":"2017-03-18T09:14:49.000Z","path":"2017/03/18/Array类型/","text":"数组类型1. 数组的创建与读取 创建 数组的创建方式有好几种，主要有以下这种： 12345var arr = [];//定义空数组var arr = [\"jack\",\"alice\",\"simon\"];//定义字符串数组var arr = new Array();//定义空数组var arr = new Array(\"jack\",\"alice\",\"simon\");//定义字符串数组var arr = new Array(3);//定义一个长度为3的空数组 读取 数组的读取比较简单，直接在数组后加上索引就可以读出了 12var arr = new Array(\"jack\",\"alice\",\"simon\");console.log(arr[1]); 思考下： 如果定义了长度为3的数组，读第四个会怎样？ 如果将数组的长度为3变为10，中间的是否可读？值为什么？长度length为多少？ 2. 检测数组 检测对象是不是数组的方法主要有以下两种： instanceof 1234var arr = new Array(\"jack\",\"alice\",\"simon\");if(arr instanceof Array)&#123; console.log('This is an Array!');&#125; 注：对于一个全局作用域而言这个很好用，但是网页中包含多个框架或者两个以上不同的全局执行环境就不适用了。 isArray() 1234var arr = new Array(\"jack\",\"alice\",\"simon\");if(Array.isArray(arr))&#123; console.log('This is an Array!');&#125; 注：Array.isArray()是ECMAScript5新增的，而且不管是在哪个全局环境中创建。但是只有IE9+、Firefox 4+、Safari 5+、Opera 10.5+和Chrome。 所以，那怎么判断又是在全局作用域而且还是不支持isArray()方法的网页中的数组的判断呢？ 还是直接上代码吧^^ 1234var arr = new Array(\"jack\",\"alice\",\"simon\");function isArray(value) &#123; return Object.prototype.toString.call(value) == \"[object Array]\";&#125; 这里的原理就是通过调用Object原生的toString()方法来返回类似[object NativeConstructorName]格式的字符串。可以打印下Object.prototype来感受下其结构。同理，该思路可以测试某值是不是原生的函数([object Function])或者正则表达式([object RegExp])等等。 3. 转换方法 转换方法主要是由数组到字符串的转化，主要有以下几种方法：toLocaleString()、toString()、valueOf()和join()等。 123456var arr = new Array(\"jack\",\"alice\",\"simon\");console.log(arr);console.log(arr.toString());console.log(arr.valueOf());console.log(arr.toLocaleString());alert(arr); 123456var arr = new Array(\"jack\",\"alice\",\"simon\");console.log(\"arr:\"+arr);console.log(\"arr.toString():\"+arr.toString());console.log(\"arr.valueOf():\"+arr.valueOf());console.log(\"arr.toLocaleString():\"+arr.toLocaleString());alert(arr); 哈哈，看到这两的结果是不是很奇怪？其实alert数组的时候会在后台调用toString方法。他们返回的都是一个以逗号分隔的字符串。那以特定字符串分隔数组的办法有么？ 123var arr = new Array(\"jack\",\"alice\",\"simon\");console.log(arr.join(\"-\"));console.log(arr.join(\"=\")); 那么问题来了,如果数组中的值是null或者undefined，在join()、toLocaleString()、toString()和valueOf()方法返回的结果又是怎样的呢？ 4. 栈方法 栈是一种LIFO（Last-In-First-Out，后入先出）的数据结构ECMAScript为数组专门提供了push()和pop()方法。因此他们只会发生在栈的顶部。具体的运用如下： push() W3C:向数组的末尾添加一个或更多元素，并返回新的长度。 var arr = new Array(\"jack\",\"alice\"); console.log(arr); // 在栈顶push两项 var ret = arr.push(\"simon\",\"edward\"); console.log(ret); console.log(arr); 结构很明显了，push的结果是返回数组的长度。 pop() W3C:删除并返回数组的最后一个元素。 var arr = new Array(\"jack\",\"alice\"); console.log(arr); // 在栈顶取出一项 var ret = arr.pop(); console.log(ret); console.log(arr); 结构很明显了，pop的结果是返回被取出的那个数组。来个小问题：如何取出栈顶的两项或者多项呢？^^(据小博主了解，好像pop是没有传参数的，那可以基于pop直接封装一个函数，传入array和要删除的项数做参数的方法，直接返回处理后的数组^^) 5. 队列方法 队列数据结构的访问规则是FIFO(First-In-First-Out,先进先出)，有两个主要的方法，shift()heunshift(),具体的用法结合push和pop可以实现对队列的操作。具体如下： shift() W3C:删除并返回数组的第一个元素。 var arr = new Array(\"jack\",\"alice\"); console.log(arr); // 在队列取出一项 var ret = arr.shift(); console.log(ret); // 原队列会变短 console.log(arr); unshift() W3C:向数组的开头添加一个或更多元素，并返回新的长度。 var arr = new Array(\"jack\",\"alice\"); console.log(arr); // 在队头插入一项 var ret = arr.unshift(\"simon\"); console.log(ret); // 原队列会变长 console.log(arr); 6. 重排序方法 数组中已经存在两个可以直接用来重排序的方法：reverse()和sort()。具体的用法如下： reverse() W3C:颠倒数组中元素的顺序。注释：该方法会改变原来的数组，而不会创建新的数组。 var arr = new Array(\"1\",\"2\",\"3\"); console.log(arr); // 结束操作后的结果 var ret = arr.reverse(); console.log(ret); console.log(arr); sort() W3C:对数组的元素进行排序,不生成副本。注释：该方法会改变原来的数组，而不会创建新的数组。 var arr = new Array(\"1\",\"2\",\"3\",\"13\",\"30\"); console.log(arr.sort()); 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（toString），以便进行比较。如果想按照其他标准进行排序，就需要提供比较函数(作为参数，通过返回一个小于、大于或者等于零的值来影响排序结果)。例如如下： function compare(value1, value2){ if (value1 &gt; value2) { return 1; }else if(value1 &lt; value2){ return -1; }else{ return 0; } } // 简写 function compare(value1, value2) { return value1 - value2; } var arr = new Array(1,2,3,15,25); console.log(arr.sort()); console.log(arr.sort(compare)); 7. 操作方法 操作方法主要有两个：concat()和slice(); concat() W3C:concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 var arr = new Array(\"jack\",\"alice\",\"simon\"); // 可以传入字符串或者数组,生成新的数组，不影响原来的数组 console.log(arr.concat(\"alice\",[\"zhou\",\"lee\"])); console.log(arr); slice() W3C:concat() 方法用于从已有的数组中返回选定的元素。arrayObject.slice(start,end)；start:必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。end:可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 var arr = new Array(\"jack\",\"alice\",\"simon\"); console.log(arr.slice(1)); console.log(arr); console.log(arr.splice(0,2)); splice() W3C:splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。 删除 var arr = new Array(\"jack\",\"alice\",\"simon\"); // 删除第一项 var removed = arr.splice(0,1); console.log(removed); console.log(arr); 插入 var arr = new Array(\"jack\",\"alice\",\"simon\"); // 插入二项项，参数：起始位置、0（要删除的项数）和要插入的数据 var removed = arr.splice(1,0,\"ken\",\"lee\"); // 返回空数组 console.log(removed); // 返回插入后的数组 console.log(arr); // 插入数组会怎样？试试咯 var removed2 = arr.splice(1,0,[\"ken\",\"lee\"]); console.log(arr); 替换 var arr = new Array(\"jack\",\"alice\",\"simon\"); // 删除的思想起始就是插入那的第二个参数，参数：起始位置、要删除的项数和要插入的项 var removed = arr.splice(1,1,\"ken\",\"lee\"); // 返回删除的字符串 console.log(removed); // 返回插入后的数组 console.log(arr); 8. 位置方法 9. 迭代方法 10. 缩小方法","tags":[{"name":"《JS高设第三版》","slug":"《JS高设第三版》","permalink":"https://jianghuasheng.github.io/tags/《JS高设第三版》/"}]},{"title":"用css样式实现瀑布流效果-columns 的运)","date":"2017-03-18T07:47:21.000Z","path":"2017/03/18/用css样式实现瀑布流效果-columns-的运/","text":"用css样式实现瀑布流效果 主要是CSS3 中的多列columns属性的运用 W3C中的columns 浏览器支持 Internet Explorer 10 和 Opera 支持 column 属性。Firefox 支持替代的 -moz-column 属性。Safari 和 Chrome 支持替代的 -webkit-column 属性。 注释：Internet Explorer 9 以及更早版本的浏览器不支持 column 属性。 CSS3 创建多列 column-count 属性规定元素应该被分隔的列数： 123456div&#123;//创建三列 column-count:3; -moz-column-count:3; /* Firefox */ -webkit-column-count:3; /* Safari 和 Chrome */ &#125; CSS3 规定列之间的间隔 column-gap 属性规定列之间的间隔： 123456 div&#123;//规定列之间 40 像素的间隔： -moz-column-gap:40px; /* Firefox */ -webkit-column-gap:40px; /* Safari 和 Chrome */ column-gap:40px; &#125; CSS3 列规则 column-rule 属性设置列之间的宽度、样式和颜色规则。 123456 div&#123;//规定列之间的宽度、样式和颜色规则： -moz-column-rule:3px outset #ff0000; /* Firefox */ -webkit-column-rule:3px outset #ff0000; /* Safari and Chrome */ column-rule:3px outset #ff0000; &#125; 新的多列属性 属性 描述 CSS column-count规定元素应该被分隔的列数。3 column-fill规定如何填充列。3 column-gap规定列之间的间隔。3 column-rule设置所有 column-rule-* 属性的简写属性。3 column-rule-color规定列之间规则的颜色。3 column-rule-style规定列之间规则的样式。3 column-rule-width规定列之间规则的宽度。3 column-span规定元素应该横跨的列数。3 column-width规定列的宽度。3 columns 规定设置 column-width 和 column-count 的简写属性。 3点击查看在线案例","tags":[]},{"title":"Hello World","date":"2017-03-16T16:04:22.517Z","path":"2017/03/17/hello-world/","text":"欢迎来到我的博客！很高兴开了这个博客，希望大家多多支持，多多交流。Hello，大家好！我叫江华生.喜欢编程!喜欢前端技术、php和java，喜欢的一起交流下。一个不愿只做技术精湛的程序猿 To make the world a little differences！","tags":[{"name":"生活杂谈","slug":"生活杂谈","permalink":"https://jianghuasheng.github.io/tags/生活杂谈/"}]}]